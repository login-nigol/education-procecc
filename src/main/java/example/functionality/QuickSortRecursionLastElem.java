package example.functionality;

import java.util.Arrays; // Импортирует класс Arrays для использования его методов, в данном случае toString(),
                        // который преобразует массив в строку.


    public class QuickSortRecursionLastElem {
        public static void main(String[] args) {

            int[] array = {17,14,15,28,6,8,-6,1,3,18};
            System.out.println("Unsorted Array: " + Arrays.toString(array));
            quickSort (array, 0, array.length-1);
            System.out.println("Sorted Array: " + Arrays.toString(array));
        }

        // Метод для рекурсивной быстрой сортировки. Определяем метод quickSort, который принимает массив arr
        // и два индекса low и max, обозначающие начало и конец подмассива для сортировки.
        public static void quickSort(int[] arr, int low, int max) {
            if (low < max) { // Условие для продолжения сортировки (если в массиве больше одного элемента)
                int pivotIndex = partition(arr, low, max); // Разделяем массив на две части относительно
                                                            // опорного элемента и возвращает его индекс.

                quickSort(arr, low, pivotIndex -1); // Рекурсивно сортируем левую часть массива, которая содержит
                                                            // элементы, меньшие опорного.
                quickSort(arr, pivotIndex + 1, max); // Рекурсивно сортируем правую часть массива, которая содержит
             // quickSort(arr, low + 1, pivotIndex);        // элементы, большие или равные опорному.
            }
        }
        // Метод для разделения массива на две части. Принимает массив и индексы low и max.
        private static int partition (int[] arr, int low, int max) {
            int pivot = arr[max]; // Выбираем последний элемент массива в качестве опорного (pivot).
            int i = (low -1); // Инициализируем переменную i, которая будет указывать на последний элемент,
                                // меньший опорного. Начальное значение low - 1.

            for (int j = low; j < max; j++) { // Проходим по каждому элементу подмассива.
                if (arr[j] > pivot) { // Если текущий элемент меньше опорного
                    i++; // Увеличиваем индекс для элементов, меньших опорного
                    // Меняем местами элементы arr[i] и arr[j]
                    int temp = arr[i]; // Меняем местами текущий элемент и элемент на позиции i,
                    arr[i] = arr[j];    // чтобы поместить меньший элемент перед опорным.
                    arr[j] = temp;
                }

            }
            // После завершения цикла перемещаем опорный элемент на правильную позицию, сразу после
            // всех элементов, меньших опорного.
            int temp2 = arr[i+ 1];
            arr[i+1] = arr[max];
            arr[max] = temp2;


            return i +1; // Возвращаем индекс, на который переместился опорный элемент, чтобы он мог быть
                            // использован в дальнейшем для разделения массива.
        }
}
